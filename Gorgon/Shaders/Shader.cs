#region LGPL.
// 
// Gorgon.
// Copyright (C) 2006 Michael Winsor
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
// 
// Created: Friday, September 22, 2006 1:03:06 AM
// 
#endregion

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Resources;
using System.IO;
using SharpUtilities;
using DX = Microsoft.DirectX;
using D3D = Microsoft.DirectX.Direct3D;
using GorgonLibrary.Internal;
using GorgonLibrary.Serialization;
using GorgonLibrary.FileSystems;

namespace GorgonLibrary.Graphics.Shaders
{
	/// <summary>
	/// Object to encapsulate pixel and vertex shader functionality.
	/// </summary>
	public class Shader
		: NamedObject, IDisposable, IDeviceStateObject, ISerializable
	{
		#region Variables.
		private ShaderTechniqueList _techniques;					// Techniques.
		private D3D.Effect _effect = null;							// Direct 3D effect.
		private ShaderParameterList _parameters;					// List of parameters.
		private ShaderTechnique _activeTechnique = null;			// Active technique.
		private string _fileName = string.Empty;					// Filename of the shader.
		private bool _isResource = false;							// Shader is a resource.
		private StringBuilder _shaderCode = null;					// Shader code.
		#endregion

		#region Properties.
		/// <summary>
		/// Property to return the effect.
		/// </summary>
		internal D3D.Effect D3DEffect
		{
			get
			{
				return _effect;
			}
		}

		/// <summary>
		/// Property to set or return the source code for the shader.
		/// </summary>
		public string ShaderSource
		{
			get
			{
				return _shaderCode.ToString();
			}
			set
			{
				string errors = string.Empty;	// Errors generated by shader compiler.

				if ((value == null) || (value == string.Empty))
					throw new InvalidResourceException("The shader has no code.", null);

				try
				{
					// Add the code.
					_shaderCode.Length = 0;
					_shaderCode.Append(value);

					// Clean up the shader.
					if (_effect != null)
						_effect.Dispose();
					_effect = null;
					_techniques.Clear();
					_parameters.Clear();
					_isResource = false;
					_fileName = Name;

					// Create the effect.
					_effect = D3D.Effect.FromString(Gorgon.Screen.Device, value, null, null, D3D.ShaderFlags.None, null, out errors);

					// Add techniques and passes.
					_techniques.Add(this);
					_parameters.Add(this);

					// Assign the first valid technique.
					foreach (ShaderTechnique technique in _techniques)
					{
						ActiveTechnique = technique;
						if (ActiveTechnique != null)
							break;
					}
				}
				catch (Exception ex)
				{
					if (_effect != null)
						_effect.Dispose();

					throw new CannotLoadException("Cannot load shader '" + _objectName + "'.\n" + errors, ex);
				}
			}
		}

		/// <summary>
		/// Property to return whether this shader is a resource or not.
		/// </summary>
		public bool IsResource
		{
			get
			{
				return _isResource;
			}
		}

		/// <summary>
		/// Property to return the shader filename.
		/// </summary>
		public string Filename
		{
			get
			{
				return _fileName;
			}
		}

		/// <summary>
		/// Property to return a list of techniques.
		/// </summary>
		public ShaderTechniqueList Techniques
		{
			get
			{
				return _techniques;
			}
		}

		/// <summary>
		/// Property to return the list of parameters.
		/// </summary>
		public ShaderParameterList Parameters
		{
			get
			{
				return _parameters;
			}
		}

		/// <summary>
		/// Property to set or return the active technique.
		/// </summary>
		public ShaderTechnique ActiveTechnique
		{
			get
			{
				return _activeTechnique;
			}
			set
			{
				// Validate.
				if (_effect == null)
					return;

				if (_techniques.Count == 0)
					throw new NoTechniquesException(Name, null);

				// Don't set the same technique.
				if (value == _activeTechnique)
					return;

				if (value != null)
				{
					// Ensure the technique is valid.
					if (_techniques[value.Name].Valid)
						_activeTechnique = value;
				}
				else
					_activeTechnique = null;
			}
		}
		#endregion

		#region Methods.
		/// <summary>
		/// Function to commit the parameters to the effect.
		/// </summary>
		internal void CommitParameters()
		{
			// Copy to the effect.
			for (int i = 0; i < _parameters.Count; i++)
				_parameters[i].Commit();
		}

		/// <summary>
		/// Function to save the shader to a stream.
		/// </summary>
		/// <param name="stream">Stream to send the shader into.</param>
		public void Save(Stream stream)
		{
			ShaderSerializer serializer = null;		// Shader serializer.

			try
			{
				serializer = new ShaderSerializer(this, stream);
				serializer.DontCloseStream = true;
				serializer.Serialize();
			}
			catch (Exception ex)
			{
				throw new CannotSaveException(_objectName, GetType(), ex);
			}
			finally
			{
				if (serializer != null)
					serializer.Dispose();
				serializer = null;
			}
		}

		/// <summary>
		/// Function to save the shader to a file.
		/// </summary>
		/// <param name="filename">Filename/path of the shader.</param>
		public void Save(string filename)
		{
			Stream stream = null;		// File stream.

			try
			{
				if (Path.GetExtension(filename) == string.Empty)
					filename += ".fx";
				stream = File.Open(filename, FileMode.Create, FileAccess.Write);
				Save(stream);

				_isResource = false;
				_fileName = filename;
			}
			catch
			{
				throw;
			}
			finally
			{
				if (stream != null)
					stream.Dispose();
				stream = null;
			}
		}

		/// <summary>
		/// Function to save the shader to a file system file.
		/// </summary>
		/// <param name="fileSystem">Filesystem to save the shader into.</param>
		/// <param name="filename">Name of the file.</param>
		public void Save(FileSystem fileSystem, string filename)
		{
			MemoryStream stream = null;		// File stream.
			byte[] data = null;				// Binary shader data.

			try
			{
				if (Path.GetExtension(filename) == string.Empty)
					filename += ".fx";

				// Save to a memory stream.
				stream = new MemoryStream();
				Save(stream);

				// Get the binary data.
				stream.Position = 0;
				data = stream.ToArray();

				// Save to the file system.
				fileSystem.WriteFile(filename, data);

				_isResource = false;
				_fileName = filename;
			}
			catch
			{
				throw;
			}
			finally
			{
				if (stream != null)
					stream.Dispose();
				stream = null;
			}
		}
		#endregion

		#region Constructor/Destructor.
		/// <summary>		
		/// Constructor.
		/// </summary>
		/// <param name="effectSource">Source code for the effect.</param>
		/// <param name="name">Name of the shader.</param>
		/// <param name="filename">Filename and path of the shader.</param>
		/// <param name="isResource">TRUE if the shader is a resource, FALSE if not.</param>
		internal Shader(string effectSource, string name, string filename, bool isResource)
			: base(name)
		{
			_shaderCode = new StringBuilder(4096);
			_isResource = isResource;
			_techniques = new ShaderTechniqueList();
			_parameters = new ShaderParameterList();
			if ((effectSource != null) && (effectSource != string.Empty))
				ShaderSource = effectSource;
            _fileName = filename;
			Gorgon.DeviceStateList.Add(this);
		}
		#endregion

		#region IDisposable Members
		/// <summary>
		/// Function to perform clean up.
		/// </summary>
		/// <param name="disposing">TRUE to release all resources, FALSE to only release unmanaged.</param>
		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
			{
				if (_effect != null)
					_effect.Dispose();

				Gorgon.DeviceStateList.Remove(this);
			}

			// Do unmanaged clean up.
			_effect = null;
		}

		/// <summary>
		/// Function to perform clean up.
		/// </summary>
		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}
		#endregion

		#region IDeviceStateObject Members
		/// <summary>
		/// Function called when the device is in a lost state.
		/// </summary>
		public void DeviceLost()
		{
			_effect.OnLostDevice();			
		}

		/// <summary>
		/// Function called when the device is reset.
		/// </summary>
		public void DeviceReset()
		{
			_effect.OnResetDevice();			
		}

		/// <summary>
		/// Function to force the loss of the objects data.
		/// </summary>
		public void ForceRelease()
		{
			DeviceLost();			
		}
		#endregion

		#region ISerializable Members
		/// <summary>
		/// Property to set or return the filename of the serializable object.
		/// </summary>
		string ISerializable.Filename
		{
			get
			{
				return _fileName;
			}
			set
			{
				if (value == null)
					value = string.Empty;

				_fileName = value;
			}
		}

		/// <summary>
		/// Function to persist the data into the serializer stream.
		/// </summary>
		/// <param name="serializer">Serializer that's calling this function.</param>
		void ISerializable.WriteData(ISerializer serializer)
		{
			byte[] code = Encoding.UTF8.GetBytes(ShaderSource);		// Shader code.

			// Write to the stream.
			serializer.Stream.Write(code, 0, code.Length);
		}

		/// <summary>
		/// Function to retrieve data from the serializer stream.
		/// </summary>
		/// <param name="serializer">Serializer that's calling this function.</param>
		void ISerializable.ReadData(ISerializer serializer)
		{
			byte[] code = null;			        // Shader code.
			int size = 0;				        // Size of shader in bytes.
            string fileName = string.Empty;     // Filename of the shader.

            fileName = _fileName;
			if (serializer.Parameters.Contains("byteSize"))
				size = serializer.Parameters.GetParameter<int>("byteSize");
			else
				throw new InvalidResourceException(_objectName, GetType(), null);

			// Create buffer.
			code = new byte[size];
			serializer.Stream.Read(code, 0, size);
			ShaderSource = Encoding.UTF8.GetString(code);
            if (fileName != string.Empty)
                _fileName = fileName;
		}
		#endregion
	}
}
