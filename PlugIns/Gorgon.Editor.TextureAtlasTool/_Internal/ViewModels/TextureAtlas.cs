#region MIT
// 
// Gorgon.
// Copyright (C) 2019 Michael Winsor
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// 
// Created: May 7, 2019 6:23:18 PM
// 
#endregion

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Gorgon.Editor.Content;
using Gorgon.Editor.Services;
using Gorgon.Editor.TextureAtlasTool.Properties;
using Gorgon.Editor.UI;
using Gorgon.Editor.UI.Controls;
using Gorgon.Graphics;
using Gorgon.Graphics.Core;
using Gorgon.IO;
using Gorgon.Math;
using Gorgon.Renderers;
using Gorgon.Renderers.Services;
using DX = SharpDX;

namespace Gorgon.Editor.TextureAtlasTool
{
    /// <summary>
    /// The view model for the main UI.
    /// </summary>
    internal class TextureAtlas
        : ViewModelBase<TextureAtlasParameters>, ITextureAtlas
    {
        #region Variables.
        // The folder browser.
        private IFileSystemFolderBrowseService _folderBrowser;
        // The message display service.
        private IMessageDisplayService _messageDisplay;
        // The busy state service.
        private IBusyStateService _busyService;
        // The settings for the texture atlas.
        private TextureAtlasSettings _settings;
        // Flag to indicate that the interface should close when canceling the file selector.
        private bool _closeOnCancel = true;
        // The atlas generation service.
        private IGorgonTextureAtlasService _atlasGen;
        // The file management service.
        private IFileIOService _fileService;
        // The base name for textures generated by the atlas.
        private string _baseTextureName;
        // The list of sprite files to load.
        private OLDE_IContentFile[] _spriteFiles = Array.Empty<OLDE_IContentFile>();
        // The generated texture atlas.
        private GorgonTextureAtlas _atlas;
        // The preview array index.
        private int _previewArrayIndex;
        // The preview texture index.
        private int _previewTextureIndex;
        // Loaded sprite data.
        private IReadOnlyDictionary<OLDE_IContentFile, GorgonSprite> _sprites = null;
        #endregion

        #region Properties.
        /// <summary>
        /// Property to return whether the interface should close when cancel is hit on the file selector.
        /// </summary>
        public bool CloseOnFileSelectorCancel
        {
            get => _closeOnCancel;
            private set
            {
                if (_closeOnCancel == value)
                {
                    return;
                }

                OnPropertyChanging();
                _closeOnCancel = value;
                OnPropertyChanged();
            }
        }

        /// <summary>Property to return the sprite file management interface.</summary>
        public ISpriteFiles SpriteFiles
        {
            get;
            private set;
        }

        /// <summary>
        /// Property to return the number of sprites loaded.
        /// </summary>
        public int LoadedSpriteCount => _spriteFiles.Length;

        /// <summary>
        /// Property to set or return the amount of padding, in pixels around each sprite on the texture.
        /// </summary>
        public int Padding
        {
            get => _settings.Padding;
            set
            {
                if (_settings.Padding == value)
                {
                    return;
                }

                OnPropertyChanging();
                _settings.Padding = value;
                OnPropertyChanged();
            }
        }

        /// <summary>Property to set or return the maximum size for the atlas texture.</summary>
        public DX.Size2 MaxTextureSize
        {
            get => _settings.MaxTextureSize;
            set
            {
                if (_settings.MaxTextureSize.Equals(value))
                {
                    return;
                }

                OnPropertyChanging();
                _settings.MaxTextureSize = value;
                OnPropertyChanged();
            }
        }

        /// <summary>Property to set or return the maximum number of array indices for the atlas texture.</summary>
        public int MaxArrayCount
        {
            get => _settings.MaxArrayCount;
            set
            {
                if (_settings.MaxArrayCount == value)
                {
                    return;
                }

                OnPropertyChanging();
                _settings.MaxArrayCount = value;
                OnPropertyChanged();
            }
        }

        /// <summary>Property to return the path for the output files.</summary>
        public string OutputPath
        {
            get => _settings.LastOutputDir;
            private set
            {
                if (string.Equals(_settings.LastOutputDir, value, StringComparison.OrdinalIgnoreCase))
                {
                    return;
                }

                OnPropertyChanging();
                _settings.LastOutputDir = value?.FormatDirectory('/');
                OnPropertyChanged();
            }
        }

        /// <summary>Property to return the base atlas texture name.</summary>
        public string BaseTextureName
        {
            get => _baseTextureName;
            set
            {
                if (string.Equals(_baseTextureName, value, StringComparison.CurrentCulture))
                {
                    return;
                }

                OnPropertyChanging();
                _baseTextureName = value;
                OnPropertyChanged();
            }
        }

        /// <summary>Property to return the folder selection command.</summary>
        public IEditorCommand<object> SelectFolderCommand
        {
            get;
        }

        /// <summary>Property to return the command used to calculate best fit sizes.</summary>
        public IEditorCommand<object> CalculateSizesCommand
        {
            get;
        }

        /// <summary>Property to return the command used to show the sprite file manager.</summary>
        public IEditorCommand<object> LoadSpritesCommand
        {
            get;
        }

        /// <summary>Property to return the command used to generate the atlas.</summary>
        public IEditorCommand<object> GenerateCommand
        {
            get;
        }

        /// <summary>
        /// Property to return the command used to commit the atlas data back to the file system.
        /// </summary>
        public IEditorCommand<CancelEventArgs> CommitAtlasCommand
        {
            get;
        }

        /// <summary>
        /// Property to set or return whether the UI is in a maximized state or not.
        /// </summary>
        public bool IsMaximized
        {
            get => _settings.IsMaximized;
            set
            {
                if (_settings.IsMaximized == value)
                {
                    return;
                }

                OnPropertyChanging();
                _settings.IsMaximized = value;
                OnPropertyChanged();
            }
        }

        /// <summary>Gets the atlas.</summary>
        public GorgonTextureAtlas Atlas
        {
            get => _atlas;
            private set
            {
                if (_atlas == value)
                {
                    return;
                }

                OnPropertyChanging();

                if (_atlas?.Textures != null)
                {
                    foreach (GorgonTexture2DView texture in _atlas.Textures)
                    {
                        texture.Dispose();
                    }
                }

                _atlas = value;
                OnPropertyChanged();

                PreviewArrayIndex = 0;
                PreviewTextureIndex = 0;
            }
        }

        /// <summary>Property to return the preview array index.</summary>
        public int PreviewArrayIndex
        {
            get => _previewArrayIndex;
            private set
            {
                if (_previewArrayIndex == value)
                {
                    return;
                }

                OnPropertyChanging();
                _previewArrayIndex = _atlas?.Textures == null ? 0 : value.Min(_atlas.Textures[_previewTextureIndex].Texture.ArrayCount - 1).Max(0);
                OnPropertyChanged();
            }
        }

        /// <summary>Property to return the preview texture index.</summary>
        public int PreviewTextureIndex
        {
            get => _previewTextureIndex;
            private set
            {
                if (_previewTextureIndex == value)
                {
                    return;
                }

                OnPropertyChanging();
                _previewTextureIndex = _atlas?.Textures == null ? 0 : value.Min(_atlas.Textures.Count - 1).Max(0);
                OnPropertyChanged();
            }
        }

        /// <summary>Property to return the command to move to the next preview item.</summary>
        public IEditorCommand<object> NextPreviewCommand
        {
            get;
        }

        /// <summary>Property to return the command to move to the previous preview item.</summary>
        public IEditorCommand<object> PrevPreviewCommand
        {
            get;
        }
        #endregion

        #region Methods.
        /// <summary>
        /// Function to determine if the atlas data can be committed back to the file system.
        /// </summary>
        /// <param name="args">The arguments to pass to the command.</param>
        /// <returns><b>true</b> if the data can be committed, <b>false</b> if not.</returns>
        private bool CanCommitAtlas(CancelEventArgs args) => (Atlas?.Textures != null) && (Atlas.Textures.Count > 0) && (_sprites != null) && (_sprites.Count > 0);

        /// <summary>
        /// Function to commit the atlas data back to the file system.
        /// </summary>
        /// <param name="args">The arguments to pass to the command.</param>
        private void DoCommitAtlas(CancelEventArgs args)
        {
            try
            {
                if (_fileService.HasExistingFiles(Atlas))
                {
                    if (_messageDisplay.ShowConfirmation(Resources.GORTAG_CONFIRM_OVERWRITE) == MessageResponse.No)
                    {
                        args.Cancel = true;
                        return;
                    }
                }

                _busyService.SetBusy();
                _fileService.SaveAtlas(_sprites, Atlas);
            }
            catch (Exception ex)
            {
                _messageDisplay.ShowError(ex, Resources.GORTAG_ERR_SAVE);
                args.Cancel = true;
            }
            finally
            {
                _busyService.SetIdle();
            }
        }

        /// <summary>
        /// Function to determine if the size of the atlas can be calculated.
        /// </summary>
        /// <returns><b>true</b> if calculation is allowed, <b>false</b> if not.</returns>
        private bool CanCalculateSize() => LoadedSpriteCount > 1;

        /// <summary>
        /// Function to calculate the best fit size of the texture and array count.
        /// </summary>
        private void DoCalculateSize()
        {
            IReadOnlyDictionary<OLDE_IContentFile, GorgonSprite> sprites = null;
            _busyService.SetBusy();

            try
            {
                sprites = _fileService.LoadSprites(_spriteFiles);

                (DX.Size2 textureSize, int arrayCount) = _atlasGen.GetBestFit(sprites.Values, new DX.Size2(256, 256), MaxArrayCount);

                if ((textureSize.Width == 0) || (textureSize.Height == 0) || (arrayCount == 0))
                {
                    _messageDisplay.ShowError(Resources.GORTAG_ERR_CALC_TOO_LARGE);
                    return;
                }

                MaxTextureSize = textureSize;
                MaxArrayCount = arrayCount;
            }
            catch (Exception ex)
            {
                _messageDisplay.ShowError(ex, Resources.GORTAG_ERR_CALC);
            }
            finally
            {
                // We no longer need the textures.
                if (sprites != null)
                {
                    foreach (GorgonSprite sprite in sprites.Values)
                    {
                        sprite.Texture?.Dispose();
                    }
                }

                _busyService.SetIdle();
            }
        }

        /// <summary>
        /// Function to browse folders on the file system.
        /// </summary>
        private void DoBrowseFolders()
        {
            try
            {
                string outputDir = _settings.LastOutputDir.FormatDirectory('/');

                if (!_fileService.DirectoryExists(outputDir))
                {
                    outputDir = "/";
                }

                outputDir = _folderBrowser.GetFolderPath(outputDir, Resources.GORTAG_CAPTION_FOLDER_SELECT, Resources.GORTAG_DESC_FOLDER_SELECT);

                if (string.IsNullOrWhiteSpace(outputDir))
                {
                    return;
                }

                OutputPath = outputDir;
            }
            catch (Exception ex)
            {
                _messageDisplay.ShowError(ex, Resources.GORTAG_ERR_FOLDER_SELECT);
            }
        }

        /// <summary>
        /// Function to determine if the atlas can be generated.
        /// </summary>
        /// <returns><b>true</b> if the atlas can be generated, <b>false</b> if not.</returns>
        private bool CanGenerate() => (LoadedSpriteCount > 1) && (!string.IsNullOrWhiteSpace(OutputPath)) && (!string.IsNullOrWhiteSpace(BaseTextureName));

        /// <summary>
        /// Function to perform the atlas generation.
        /// </summary>
        private void DoGenerate()
        {
            GorgonTextureAtlas atlas = null;
            _busyService.SetBusy();

            void UnloadAtlasTextures()
            {
                if (atlas == null)
                {
                    return;
                }

                foreach (GorgonTexture2DView texture in atlas.Textures)
                {
                    texture.Dispose();
                }
            }

            try
            {
                _sprites = _fileService.LoadSprites(_spriteFiles);

                Debug.Assert(_sprites.Count != 0, "No sprites were returned.");

                // If any of the sprites returned are not linked to a texture, give the user a chance to fix the problem.
                if (_sprites.Values.All(item => item.Texture == null))
                {
                    _messageDisplay.ShowError(Resources.GORTAG_ERR_NO_TEXTURES);
                    return;
                }

                if (_sprites.Values.Any(item => item.Texture == null))
                {
                    _busyService.SetIdle();
                    if (_messageDisplay.ShowConfirmation(Resources.GORTAG_CONFIRM_SOME_NO_TEXTURE) == MessageResponse.No)
                    {
                        return;
                    }
                }

                GorgonTexture2DView texture = _sprites.Values.First().Texture;
                if (_sprites.Values.All(item => item.Texture == texture))
                {
                    _messageDisplay.ShowInfo(Resources.GORTAG_INF_ALREADY_ATLASED);
                    return;
                }

                _busyService.SetBusy();
                _atlasGen.Padding = _settings.Padding;
                _atlasGen.ArrayCount = _settings.MaxArrayCount;
                _atlasGen.TextureSize = _settings.MaxTextureSize;
                _atlasGen.BaseTextureName = $"{_settings.LastOutputDir}{_baseTextureName.FormatFileName()}";

                IReadOnlyDictionary<GorgonSprite, (int textureIndex, DX.Rectangle region, int arrayIndex)> regions = _atlasGen.GetSpriteRegions(_sprites.Values);

                if ((regions == null) || (regions.Count == 0))
                {
                    _messageDisplay.ShowError(Resources.GORTAG_ERR_NO_ROOM);
                    return;
                }

                atlas = _atlasGen.GenerateAtlas(regions, BufferFormat.R8G8B8A8_UNorm);

                if ((atlas == null) || (atlas.Textures == null) || (atlas.Sprites == null) || (atlas.Textures.Count == 0))
                {
                    _messageDisplay.ShowError(Resources.GORTAG_ERR_GEN_ATLAS);
                    return;
                }

                Atlas = atlas;
            }
            catch (Exception ex)
            {
                if ((atlas?.Textures != null) && (Atlas != atlas))
                {
                    UnloadAtlasTextures();
                }

                _messageDisplay.ShowError(ex, Resources.GORTAG_ERR_GEN_ATLAS);
            }
            finally
            {
                // We no longer need the textures.
                if (_sprites != null)
                {
                    foreach (GorgonSprite sprite in _sprites.Values)
                    {
                        sprite.Texture?.Dispose();
                    }
                }
                _busyService.SetIdle();
            }
        }

        /// <summary>
        /// Function to determine whether sprites can be loaded or not.
        /// </summary>
        /// <returns><b>true</b> if the sprites can be loaded, <b>false</b> if not.</returns>
        private bool CanLoadSprites() => SpriteFiles.SelectedFiles.Count > 1;

        /// <summary>
        /// Function to load the selected sprites.
        /// </summary>
        private void DoLoadSprites()
        {
            _busyService.SetBusy();

            try
            {
                _spriteFiles = SpriteFiles.SelectedFiles.Select(item => item.File).ToArray();

                SpriteFiles.IsActive = false;
                CloseOnFileSelectorCancel = false;
                NotifyPropertyChanged(nameof(LoadedSpriteCount));

                if (string.IsNullOrWhiteSpace(_settings.LastOutputDir))
                {
                    OutputPath = Path.GetDirectoryName(SpriteFiles.SelectedFiles[0].File.Path).FormatDirectory('/');
                }
            }
            catch (Exception ex)
            {
                _messageDisplay.ShowError(ex, Resources.GORTAG_ERR_LOAD_SPRITES);
            }
            finally
            {
                _busyService.SetIdle();
            }
        }

        /// <summary>
        /// Function to show the sprite file manager.
        /// </summary>
        private void DoShowLoadSprites()
        {
            _busyService.SetBusy();

            try
            {
                // Restore the file selection list.
                foreach (ContentFileExplorerFileEntry file in SpriteFiles.SpriteFileEntries.SelectMany(item => item.Files))
                {
                    file.IsSelected = Array.IndexOf(_spriteFiles, file.File) != -1;
                }

                SpriteFiles.IsActive = true;
            }
            catch (Exception ex)
            {
                _messageDisplay.ShowError(ex, Resources.GORTAG_TEXT_SHOW_LOAD_SPRITE);
            }
            finally
            {
                _busyService.SetIdle();
            }
        }

        /// <summary>
        /// Function to determine we can move to the next preview image.
        /// </summary>
        /// <returns><b>true</b> if possible, <b>false</b> if not.</returns>
        private bool CanNextPreview()
        {
            if ((Atlas?.Textures == null) || (Atlas.Textures.Count == 0))
            {
                return false;
            }

            GorgonTexture2D texture = Atlas.Textures[PreviewTextureIndex].Texture;

            return ((PreviewArrayIndex + 1 < texture.ArrayCount) || (PreviewTextureIndex + 1 < Atlas.Textures.Count));
        }

        /// <summary>
        /// Function to move to the next index in the preview.
        /// </summary>
        private void DoNextPreview()
        {
            try
            {
                GorgonTexture2D texture = Atlas.Textures[PreviewTextureIndex].Texture;

                if (PreviewArrayIndex + 1 >= texture.ArrayCount)
                {
                    PreviewTextureIndex++;
                    PreviewArrayIndex = 0;
                }
                else
                {
                    PreviewArrayIndex++;
                }
            }
            catch (Exception ex)
            {
                _messageDisplay.ShowError(ex, Resources.GORTAG_ERR_PREVIEW_ARRAY);
            }
        }

        /// <summary>
        /// Function to determine we can move to the next preview image.
        /// </summary>
        /// <returns><b>true</b> if possible, <b>false</b> if not.</returns>
        private bool CanPrevPreview() => (Atlas?.Textures == null) || (Atlas.Textures.Count == 0)
                ? false
                : (PreviewArrayIndex - 1 >= 0) || (PreviewTextureIndex - 1 >= 0);

        /// <summary>
        /// Function to move to the next index in the preview.
        /// </summary>
        private void DoPrevPreview()
        {
            try
            {
                if (PreviewArrayIndex - 1 < 0)
                {
                    PreviewTextureIndex--;
                    PreviewArrayIndex = 0;
                }
                else
                {
                    PreviewArrayIndex--;
                }
            }
            catch (Exception ex)
            {
                _messageDisplay.ShowError(ex, Resources.GORTAG_ERR_PREVIEW_ARRAY);
            }
        }

        /// <summary>Function to inject dependencies for the view model.</summary>
        /// <param name="injectionParameters">The parameters to inject.</param>
        /// <remarks>
        /// Applications should call this when setting up the view model for complex operations and/or dependency injection. The constructor should only be used for simple set up and initialization of objects.
        /// </remarks>
        protected override void OnInitialize(TextureAtlasParameters injectionParameters)
        {
            _settings = injectionParameters.Settings ?? throw new ArgumentMissingException(nameof(injectionParameters.Settings), nameof(injectionParameters));
            SpriteFiles = injectionParameters.SpriteFiles ?? throw new ArgumentMissingException(nameof(injectionParameters.SpriteFiles), nameof(injectionParameters));
            _folderBrowser = injectionParameters.FolderBrowser ?? throw new ArgumentMissingException(nameof(injectionParameters.FolderBrowser), nameof(injectionParameters));
            _busyService = injectionParameters.BusyService ?? throw new ArgumentMissingException(nameof(injectionParameters.BusyService), nameof(injectionParameters));
            _messageDisplay = injectionParameters.MessageDisplay ?? throw new ArgumentMissingException(nameof(injectionParameters.MessageDisplay), nameof(injectionParameters));
            _atlasGen = injectionParameters.AtlasGenerator ?? throw new ArgumentMissingException(nameof(injectionParameters.AtlasGenerator), nameof(injectionParameters));
            _fileService = injectionParameters.FileManager ?? throw new ArgumentMissingException(nameof(injectionParameters.FileManager), nameof(injectionParameters));

            PreviewArrayIndex = PreviewTextureIndex = 0;
            SpriteFiles.IsActive = true;
        }

        /// <summary>Function called when the associated view is loaded.</summary>
        public override void OnLoad()
        {
            base.OnLoad();

            if (SpriteFiles != null)
            {
                SpriteFiles.ConfirmLoadCommand = new EditorCommand<object>(DoLoadSprites, CanLoadSprites);
            }
        }

        /// <summary>Function called when the associated view is unloaded.</summary>
        public override void OnUnload()
        {
            if (SpriteFiles != null)
            {
                SpriteFiles.ConfirmLoadCommand = null;
            }

            if (_sprites != null)
            {
                foreach (KeyValuePair<OLDE_IContentFile, GorgonSprite> sprite in _sprites)
                {
                    sprite.Value?.Texture?.Dispose();
                }
            }

            _sprites = null;
            _spriteFiles = Array.Empty<OLDE_IContentFile>();
            Atlas = null;
            CloseOnFileSelectorCancel = true;

            base.OnUnload();
        }
        #endregion

        #region Constructor/Finalizer.
        /// <summary>Initializes a new instance of the <see cref="TextureAtlas"/> class.</summary>
        public TextureAtlas()
        {
            LoadSpritesCommand = new EditorCommand<object>(DoShowLoadSprites);
            GenerateCommand = new EditorCommand<object>(DoGenerate, CanGenerate);
            SelectFolderCommand = new EditorCommand<object>(DoBrowseFolders);
            CalculateSizesCommand = new EditorCommand<object>(DoCalculateSize, CanCalculateSize);
            NextPreviewCommand = new EditorCommand<object>(DoNextPreview, CanNextPreview);
            PrevPreviewCommand = new EditorCommand<object>(DoPrevPreview, CanPrevPreview);
            CommitAtlasCommand = new EditorCommand<CancelEventArgs>(DoCommitAtlas, CanCommitAtlas);
        }
        #endregion
    }
}
